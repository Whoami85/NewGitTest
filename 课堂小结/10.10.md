[TOC]

# 10.10小结

## 一、es6新特性

1. let\const
2. 数组的拓展
3. 函数拓展
4. 字符串拓展
5. Set\Map
6. Promise
7. 对象拓展
8. Symbol
9. 正则拓展
10. proxy
11. Reflect
12. async await（es8）
13. class
14. 生成器
15. 迭代器
16. 剩余运算符
17. 解构赋值

# 二、课堂小结

## **1、let\const与var的区别**

- let是用于替代var来声明变量（var是ES6之前用来声明变量的关键词）
- const是用来声明常量的（var，let声明变量时，变量一旦初始化之后，还可以重新赋值，const声明常量，一旦初始化，就不能重新赋值了，否则会报错）
- var允许重复声明，let、const不允许
- var会提升变量的声明到作用域的顶部，但let和const不会（说白了就是let和const没有变量提升）
- 只要作用域内存在let、const，它们所声明的变量或常量就会自动“绑定”这个区域，不再受外部作用域的影响
- 全局作用域中，var声明的变量，通过function声明的函数，会自动变为window对象的变量，属性或方法，但const和let不会
- var没有块级作用域，let和const有块级作用域

## **2、数组的拓展**

（1）Array.from()将类数组(array-like)对象与可遍历的对象转化为数组并返回。

（2）Array.of方法用于将一组值，转换为数组。

（3）数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。

Array.prototype.copyWithin(target, start = 0, end = this.length)它接受三个参数:

- target（必需）：从该位置开始替换数据。
- start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数.

这三个参数都应该是数值，如果不是，会自动转为数值。

（4）**数组实例的find()和findIndex()**

数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。

数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。(找到一个符合的就停止)

（5）**数组实例的fill()**

fill方法使用给定值，填充一个数组。

（6）**数组实例的entires(),keys()和value()**

ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。

（7）**数组实例的includes()**

Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。

（8）**数组的空位**

数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。

~~~
Array（3）// [ , , ,]
~~~



上面代码中，Array(3)返回一个具有3个空位的数组。

注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值。

## **3、函数的拓展**

1. 函数参数的默认值

   ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。

   ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。

2. 与解构赋值默认值结合使用

   参数默认值可以与解构赋值的默认值，结合起来使用。

   ~~~
   function foo({x, y = 5}) {
     console.log(x, y);
   }
    
   foo({}) // undefined 5
   foo({x: 1}) // 1 5
   foo({x: 1, y: 2}) // 1 2
   foo() // TypeError: Cannot read property 'x' of undefined
   ~~~



   上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数`foo`的参数是一个对象时，变量`x`和`y`才会通过解构赋值生成。如果函数`foo`调用时没提供参数，变量`x`和`y`就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。

   ~~~
   function foo({x, y = 5} = {}) {
     console.log(x, y);
   }
    
   foo() // undefined 5
   ~~~



   上面代码指定，如果没有提供参数，函数`foo`的参数默认为一个空对象。

3. 作用域

   一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。

4. rest参数 

   ES6 引入 rest 参数（形式为`...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

   ~~~
   function add(...values) {
     let sum = 0;
    
     for (var val of values) {
       sum += val;
     }
    
     return sum;
   }
    
   add(2, 5, 3) // 10
   ~~~



   上面代码的`add`函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。

   下面是一个 rest 参数代替`arguments`变量的例子。

   ~~~
   // arguments变量的写法
   function sortNumbers() {
     return Array.from(arguments).sort();
   }
    
   // rest参数的写法
   const sortNumbers = (...numbers) => numbers.sort();
   ~~~



   上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。

5. name属性

   函数的`name`属性，返回该函数的函数名。

   ~~~
   function foo() {}
   foo.name // "foo"
   ~~~

6. 箭头函数

   ES6 允许使用“箭头”（`=>`）定义函数。

   ~~~
   var f = v => v;
    
   // 等同于
   var f = function (v) {
     return v;
   };
   ~~~

   如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。

   ~~~
   var f = () => 5;
   // 等同于
   var f = function () { return 5 };
    
   var sum = (num1, num2) => num1 + num2;
   // 等同于
   var sum = function(num1, num2) {
     return num1 + num2;
   };
   ~~~



   如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用`return`语句返回。

   ~~~
   var sum = (num1, num2) => { return num1 + num2; }

   ~~~

   由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。

   ~~~
   // 报错
   let getTempItem = id => { id: id, name: "Temp" };
    
   // 不报错
   let getTempItem = id => ({ id: id, name: "Temp" });
   ~~~


## **4、箭头函数与普通函数的区别**

- 1、外形不同：箭头函数使用箭头定义，普通函数中没有。
- 2、 箭头函数全都是匿名函数：普通函数可以有匿名函数，也可以有具名函数
- 3、箭头函数不能用于构造函数：普通函数可以用于构造函数，以此创建对象实例。
- 4、箭头函数中 this 的指向不同：在普通函数中，this 总是指向调用它的对象，如果用作构造函数，它指向创建的对象实例。
- 5、箭头函数不具有 arguments 对象：每一个普通函数调用后都具有一个arguments 对象，用来存储实际传递的参数。但是箭头函数并没有此对象。
- 6、其他区别：箭头函数不具有 prototype 原型对象。箭头函数不具有 super。箭头函数不具有 new.target

## **5、字符串拓展**

### （1）子串识别

　　自从 JS 引入了 indexOf() 方法，开发者们就使用它来识别字符串是否存在于其它字符串中。ES6 包含了以下三个方法来满足这类需求：includes()、startsWith()、endsWith()

【includes()】

　　该方法在给定文本存在于字符串中的任意位置时会返回 true ，否则返回false

【startsWith()】

　　该方法在给定文本出现在字符串起始处时返回 true ，否则返回 false

【endsWith()】

　　该方法在给定文本出现在字符串结尾处时返回 true ，否则返回 false 

　　以上每个方法都接受两个参数：需要搜索的文本，以及可选的搜索起始位置索引

　　当提供了第二个参数(假设为n)时， includes() 与 startsWith() 方法会从该索引位置(n)开始尝试匹配；而endsWith() 方法则从字符串长度减去这个索引值的位置开始尝试匹配

　　当第二个参数未提供时， includes() 与 startsWith() 方法会从字符串起始处开始查找，而 endsWith() 方法则从尾部开始。实际上，第二个参数减少了搜索字符串的次数

### （2）字符串重复

【repeat()】

　　ES6为字符串添加了一个 repeat() 方法，它接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串

### （3）字符串补全

　　ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全

【padStart()】

　　头部补全

【padEnd()】

　　尾部补全

`　　padStart()`和`padEnd()`一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串

## **6、Set\Map的区别**

Set 和 Map 主要的应用场景在于 **数据重组** 和 **数据储存**。

Set 本身是一种构造函数，用来生成 Set 数据结构。

Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。

**Map**是一组键值对的结构，用于解决以往不能用对象做为键的问题，具有极快的查找速度。(注：函数、对象、基本类型都可以作为键或值。)**一个key只能对应一个value**，所以多次对一个key放入value，后面的值会把前面的值冲掉

Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，**没有重复的key。**

这也就是为什么可以用set（）来进行去重。

**区别：**

- 1.Map是键值对，Set是值的集合，当然键和值可以是任何的值；
- 2.Map可以通过get方法获取值，而set不能因为它只有值；

- 3.都能通过迭代器进行for...of遍历；

- 4.Set的值是唯一的可以做数组去重，Map由于没有格式限制，可以做数据存储

- 5.map和set都是stl中的关联容器，map以键值对的形式存储，key=value组成pair，是一组映射关系。set只有值，可以认为只有一个数据，并且set中元素不可以重复且自动排序。

## **7、Map与Object的不同**

**概念**
Object

在ECMAScript中，Object是一个特殊的对象。它本身是一个顶级对象，同时还是一个构造函数，可以通过它（如：new Object()）来创建一个对象。我们可以认为JavaScript中所有的对象都是Object的一个实例，对象可以用字面量的方法const obj = {}即可声明。
Map

Map是Object的一个子类，可以有序保存任意类型的数据，使用键值对去存储，其中键可以存储任意类型，通过const m = new Map();即可得到一个map实例。

**访问**

map: 通过map.get(key)方法去属性, 不存在则返回undefined

object: 通过obj.a或者obj[‘a’]去访问一个属性, 不存在则返回undefined

**赋值**
map: 通过map.set去设置一个值，key可以是任意类型

object: 通过object.a = 1或者object[‘a’] = 1，去赋值，key只能是字符串，数字或symbol

**删除**
map: 通过map.delete去删除一个值，试图删除一个不存在的属性会返回false

object: 通过delete操作符才能删除对象的一个属性，诡异的是，即使对象不存在该属性，删除也返回true，当然可以通过Reflect.deleteProperty(target, prop) 删除不存在的属性还是会返回true。

~~~
var obj = {}; // undefined
delete obj.a // true
~~~

**大小**
map: 通过map.size即可快速获取到内部元素的总个数

object: 需要通过Object.keys的转换才能将其转换为数组，再通过数组的length方法去获得或者使用Reflect.ownKeys(obj)也可以获取到keys的集合

**迭代**
map: 拥有迭代器，可以通过for-of forEach去直接迭代元素，切遍历顺序是确定的

object: 并没有实现迭代器，需要自行实现，不实现只能通过for-in循环去迭代，遍历顺序是不确定的

**使用场景**
如果只需要简单的存储key-value的数据，并且key不需要存储复杂类型的，直接用对象
如果该对象必须通过JSON转换的，则只能用对象，目前暂不支持Map
map的阅读性更好，所有操作都是通过api形式去调用，更有编程体验

## **8、WeakMap\WeakSet**

#### WeakSet

WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 区别如下。

- **WeakSet 的成员只能是对象，而不能是其他类型的值**
- **WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用**
  也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。**WeakSet结构有助于防止内存泄漏**
- **WeakSet没有size属性和forEach方法**
  WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。

WeakSet 有以下三个方法：

- **WeakSet.prototype.add(value)：**向 WeakSet 实例添加一个新成员。
- **WeakSet.prototype.delete(value)：**清除 WeakSet 实例的指定成员。
- **WeakSet.prototype.has(value)：**返回一个布尔值，表示某个值是否在 WeakSet 实例之中。

#### WeakMap

WeakMap结构与Map结构类似，也是用于生成键值对的集合。WeakMap与Map的区别有以下几点：

- **WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名**
- **WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内**
  也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。**总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。**
- **同 WeakSet 一样，WeakMap也没有遍历操作，即 (keys()、values()和entries()方法)**
  因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。
- **不支持clear方法**

WeakMap 有以下四个个方法：

- **get()：** 通过键名取值
- **set()：** 设置键值对
- **has()：** 判断是否存在
- **delete()：** 删除一项记录

## **9、对象拓展**

- ##### 属性的简洁表示法

~~~
const foo = 'bar';
const baz = {foo};
baz // {foo: "bar"}
 
// 等同于
const baz = {foo: foo};
复制代码
~~~

- ##### 属性名表达式

JavaScript 定义对象的属性，有两种方法。

~~~
// 方法一
obj.foo = true;
 
// 方法二
obj['a' + 'bc'] = 123;
复制代码
~~~



上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。 ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。

- ##### 方法的name属性 

函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。

~~~
const person = {
  sayName() {
    console.log('hello!');
  },
};
 
person.sayName.name   // "sayName"
//上面代码中，方法的name属性返回函数名（即方法名）。
~~~



- ##### 属性的遍历

ES6 一共有 5 种方法可以遍历对象的属性。

（1）for...in

for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

（2）Object.keys(obj)

Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

（3）Object.getOwnPropertyNames(obj)

Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。

（4）Object.getOwnPropertySymbols(obj)

Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。

（5）Reflect.ownKeys(obj)

Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。

1. 首先遍历所有数值键，按照数值升序排列。
2. 其次遍历所有字符串键，按照加入时间升序排列。
3. 最后遍历所有 Symbol 键，按照加入时间升序排列。

~~~
Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// ['2', '10', 'b', 'a', Symbol()]
~~~

上面代码中，`Reflect.ownKeys`方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性`2`和`10`，其次是字符串属性`b`和`a`，最后是 Symbol 属性。

- ##### 解构赋值

对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。

~~~
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
~~~



上面代码中，变量`z`是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（`a`和`b`），将它们连同值一起拷贝过来。

由于解构赋值要求等号右边是一个对象，所以如果等号右边是`undefined`或`null`，就会报错，因为它们无法转为对象。

~~~
let { ...z } = null; // 运行时错误
let { ...z } = undefined; // 运行时错误
~~~

解构赋值必须是最后一个参数，否则会报错。

~~~
let { ...x, y, z } = someObject; // 句法错误
let { x, ...y, ...z } = someObject; // 句法错误
~~~



上面代码中，解构赋值不是最后一个参数，所以会报错。

注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。

~~~
let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2;
x.a.b // 2
~~~



上面代码中，`x`是解构赋值所在的对象，拷贝了对象`obj`的`a`属性。`a`属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。



- ##### 拓展运算符

对象的扩展运算符（`...`）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。

~~~
let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
~~~



由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。

~~~
let foo = { ...['a', 'b', 'c'] };
foo
// {0: "a", 1: "b", 2: "c"}
~~~

如果扩展运算符后面是一个空对象，则没有任何效果。

~~~
{...{}, a: 1}
// { a: 1 }
~~~



如果扩展运算符后面不是对象，则会自动将其转为对象。

~~~
// 等同于 {...Object(1)}
{...1} // {}
~~~



上面代码中，扩展运算符后面是整数`1`，会自动转为数值的包装对象`Number{1}`。由于该对象没有自身属性，所以返回一个空对象。

扩展运算符可以用于合并两个对象。

```
let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
```





